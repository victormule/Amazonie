<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quai Branly ‚Äì Mem√≥ria & Alma</title>

    <link rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<script defer
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- ================== ESTILOS ================== -->
    <style>
      :root {
        --bg: #111;
        --text: #f5f5f5;
        --accent: #f59e0b;
        --border: #444;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        padding: 2rem 1rem;
        font-family: system-ui, sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      h1 {
        margin: 0 0 3rem;
        font-size: 2.5rem;
        letter-spacing: .05em;
        text-align: center;
      }
      .artefact { display: flex; align-items: flex-start; gap: 1.5rem; margin-bottom: 3rem; }
      .artefact img { width: 45%; height: auto; object-fit: contain; box-shadow: 0 4px 16px rgba(0,0,0,.6); }
      .panel { flex: 1; border: 1px solid var(--border); padding: 1rem; display: flex; flex-direction: column; max-height: 600px; }
      .panel-upper { flex: 1 1 auto; overflow-y: auto; margin-bottom: 1rem; padding-right: .5rem; }
      .note { background: rgba(255,255,255,.05); padding: .5rem .75rem; margin: 0 0 .5rem; border-radius: 4px; font-size: .9rem; }
      .panel-lower { border-top: 1px solid var(--border); padding-top: 1rem; }
      textarea, input[type="text"] { width: 100%; background:#222; color:var(--text); border:1px solid var(--border); border-radius:4px; padding:.5rem; margin-bottom:.5rem; }
      textarea { min-height:60px; resize:vertical; }
      button { background:var(--accent); border:none; color:#000; padding:.5rem 1rem; border-radius:4px; cursor:pointer; }
      button:hover { filter:brightness(1.1); }
      .preview { display:flex; align-items:center; gap:.5rem; margin-top:.5rem; }
      .preview button { padding:0 .4rem; }
      .load-more-comments { display: block; width: 100%; margin-top: 1rem; background: rgba(255,255,255,.1); color: var(--text); }
      .play-audio { background: rgba(255,255,255,.1); color: var(--text); padding: .3rem .5rem; font-size: .8rem; }
      #loading-indicator { text-align: center; padding: 1rem; color: var(--accent); display: none; }
      
      .privacy-link {
        text-align: center;
        margin-bottom: 1rem;
      }
      .privacy-link a {
        color: var(--text);
        text-decoration: none;
        border-bottom: 1px dotted var(--border);
        font-size: 0.9rem;
      }
      .privacy-link a:hover {
        color: var(--accent);
        border-color: var(--accent);
      }
      
      .delete-btn {
        background: transparent;
        color: #ff4d4d;
        border: 1px solid #ff4d4d;
        font-size: 0.8rem;
        padding: 0.25rem 0.5rem;
        margin-top: 0.5rem;
        cursor: pointer;
        border-radius: 3px;
      }
      .delete-btn:hover {
        background: rgba(255, 77, 77, 0.1);
      }
      
      .rec-info {
        margin-left: .5rem;
        font-size: .8rem;
        color: #ccc;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 5px 0;
      }
      
      .size-warning {
        color: #ff9a3c;
      }
      
      .size-critical {
        color: #ff4d4d;
      }
      
      /* Limite d'agrandissement : 200 px */
textarea {
  min-height: 60px;
  max-height: 200px;   /* ‚Üê nouvelle ligne */
  resize: vertical;
  overflow-x: hidden;          /* pas de scroll horizontal */
  white-space: pre-wrap;       /* conserve les sauts de ligne mais wrappe */
  word-break: break-word;      /* coupe les mots / URLs trop longs */
  overflow-wrap: anywhere;     /* comportement moderne √©quivalent */
}
.char-count {
  font-size: .75rem;
  text-align: right;
  color: #aaa;
  margin-top: -6px;     /* remonte un peu sous le textarea */
  margin-bottom: .5rem;
}

      .note {
  word-break: break-word;      /* coupe mots/URLs dans la bulle affich√©e */
  overflow-wrap: anywhere;
}
/* Boutons sur la carte */
.map-btn {
  position: absolute;
  bottom: 10px;
  padding: .4rem .8rem;
  background: var(--accent);
  border: none;
  color: #000;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  z-index: 1500;       /* Plus haut que les contr√¥les Leaflet */
}
.map-btn:hover { filter: brightness(1.1); }
#saveLoc { left: 10px; }       /* coin bas-gauche */
#closeMap { right: 10px; }     /* coin bas-droit */

/* Style du container du modal pour la carte */
#map-modal {
  position: fixed;
  inset: 0;
  z-index: 9999;
  background: rgba(0,0,0,.8);
  display: none;
  align-items: center;
  justify-content: center;
}

#map-modal > div {
  width: 90%;
  max-width: 600px;
  height: 80vh;
  position: relative;
  background: #222;
  border: 1px solid #555;
}

/* conteneur vertical : banni√®re en haut, carte qui prend le reste */
.map-wrapper {
  display: flex;
  flex-direction: column;
  width: 90%;
  max-width: 600px;
  height: 80vh;
  position: relative;
  background: #222;
  border: 1px solid #555;
}

/* banni√®re */
.map-banner {
  background: #333;
  color: #f5f5f5;
  padding: 0.6rem 1rem;
  text-align: center;
  font-weight: 600;
  border-bottom: 1px solid #555;
}

/* la carte doit occuper tout l'espace restant */
#leaflet-container {
  flex: 1 1 auto;           /* ‚Üê le plus important */
  height: auto;             /* on n'a plus besoin d'une hauteur fixe */
  width: 100%;
  position: relative;
  z-index: 1000;
}
      .note .comment-media {
  margin: .25rem 0 .5rem;
}
.note .comment-media img {
  max-width: 100%;
  max-height: 220px;      /* garde le bloc harmonieux */
  display: block;
  object-fit: contain;    /* pas d‚Äô√©tirement */
  border-radius: 4px;
  border: 1px solid var(--border);
}

      
      @media (max-width:768px){ .artefact{flex-direction:column;} .artefact img{width:100%;} }
    </style>

    
  </head>
  <body>
    <h1>Quai Branly ‚Äì <span style="color:var(--accent)">Mem√≥ria & Alma</span></h1>
    <p style="text-align:justify; max-width:800px; margin:0 auto 2rem; line-height:1.6">
  Este projeto tem como objetivo restituir <strong>o esp√≠rito</strong> e <strong>a mem√≥ria</strong> 
  dos objetos etnogr√°ficos brasileiros preservados no Mus√©e du Quai Branly (Fran√ßa).
</p>

<p style="text-align:justify; max-width:800px; margin:0 auto 2rem; line-height:1.6">
  Com a participa√ß√£o das <strong>comunidades ind√≠genas da Amaz√¥nia</strong>, 
  o projeto convida a enriquecer esses artefatos por meio de testemunhos escritos e orais: hist√≥rias, cantos, nomes ou lembran√ßas ligados aos povos e culturas de origem.
</p>

<p style="text-align:justify; max-width:800px; margin:0 auto 2rem; line-height:1.6">
  Muitos desses objetos chegaram √†s cole√ß√µes ocidentais por meio de processos de expropria√ß√£o e saque.
</p>

<p style="text-align:justify; max-width:800px; margin:0 auto 2rem; line-height:1.6">
  Atrav√©s deste projeto, buscamos fazer ecoar a voz dos povos ind√≠genas dentro do museu, 
  para ressignificar esses artefatos e questionar as responsabilidades hist√≥ricas das institui√ß√µes que os conservam.
</p>
    <div class="privacy-link"><a href="privacy.html">Pol√≠tica de Privacidade</a></div>
    <div><br></div>
    <div id="gallery"></div>
    <div id="loading-indicator">Carregando mais artefatos...</div>

    <div id="map-modal">
        <div class="map-wrapper">            <!-- classe ajout√©e -->
    <div class="map-banner">O√π trouve-t-on cet objet&nbsp;?</div> <!-- BANNI√àRE -->
      
        <div id="leaflet-container"></div>
        <button id="saveLoc" class="map-btn">üíæ Salvar</button>
        <button id="closeMap" class="map-btn">‚úñÔ∏è</button>
      </div>
    </div>
    
    <script>
      /* ===== CONFIG ===== */
      // Remplace pelo URL do seu projeto Supabase (sem barra final)
      const SUPABASE_URL = "https://mzcepywscpmbzvcouwuj.supabase.co";
      const MAX_AUDIO_BYTES = 4 * 1024 * 1024; 
      // Seuils d'avertissement (80% et 95% de la taille maximale)
      const WARNING_THRESHOLD = 0.8 * MAX_AUDIO_BYTES;
      const CRITICAL_THRESHOLD = 0.95 * MAX_AUDIO_BYTES;
      // Intervalle pour r√©cup√©rer des donn√©es pendant l'enregistrement (200ms)
      const RECORDING_TIMESLICE = 1000;

      const images = [
        { src: "assets/image1.png", alt: "Peitoral de penas e contas" },
        { src: "assets/image2.png", alt: "Cinto tran√ßado com penas" },
        { src: "assets/image3.png", alt: "Coroa cerimonial" },
        { src: "assets/image4.png", alt: "Cesto ritual" },
        { src: "assets/image5.png", alt: "Pente frontal" },
        { src: "assets/image6.png", alt: "Brincos de penas" },
        { src: "assets/image7.png", alt: "Coroa cerimonial" },
        { src: "assets/image8.png", alt: "Cesto ritual" },
        { src: "assets/image9.png", alt: "Pente frontal" },
        { src: "assets/image10.png", alt: "Brincos de penas" },
      ];

      const gallery = document.getElementById('gallery');
      const loadingIndicator = document.getElementById('loading-indicator');
      const messageCache = {}; // Cache pour les messages
      
      // Variables pour le scroll infini
      let currentIndex = 0;
      let isLoading = false;

      /* === helpers === */
      const blobToBase64 = blob => new Promise(r => {
        const fr = new FileReader();
        fr.onload = () => r(fr.result.split(',')[1]);
        fr.readAsDataURL(blob);
      });
      
      function generateSecretKey() {
        return Array.from(crypto.getRandomValues(new Uint8Array(16)))
          .map(b => b.toString(16).padStart(2, "0"))
          .join("");
      }
      
      function formatTime(sec) {
        if (!Number.isFinite(sec)) return "00:00"; // Protection contre les valeurs non num√©riques
        const m = Math.floor(sec / 60).toString().padStart(2,'0');
        const s = Math.floor(sec % 60).toString().padStart(2,'0');
        return `${m}:${s}`;
      }
      
      function formatFileSize(bytes) {
        if (bytes === 0) return "0 B";
        if (bytes < 1024) return bytes + " B";
        const kb = bytes / 1024;
        if (kb < 1024) return kb.toFixed(1) + " KB";
        const mb = kb / 1024;
        return mb.toFixed(2) + " MB";
      }
      
      async function deleteMessage(messageId, secretKey, artefactId, upperPanel, loadMoreBtn) {
        if (!confirm('Tem certeza que deseja excluir este coment√°rio?')) return;
        
        try {
          const res = await fetch('/.netlify/functions/delete-message', {
            method: 'POST',
            body: JSON.stringify({ id: messageId, delete_token: secretKey })
          });
          
          const result = await res.text();
          if (result === 'ok') {
            // Suppression r√©ussie, mettre √† jour localStorage
            const userMessages = JSON.parse(localStorage.getItem('userMessages') || '{}');
            delete userMessages[messageId];
            localStorage.setItem('userMessages', JSON.stringify(userMessages));
            
            // Vider le cache pour cet artefact
            Object.keys(messageCache).forEach(key => {
              if (key.startsWith(artefactId)) delete messageCache[key];
            });
            
            // Recharger les messages
            const currentPage = 0;
            loadMessages(artefactId, upperPanel).then(hasMore => {
              if (loadMoreBtn) loadMoreBtn.style.display = hasMore ? 'block' : 'none';
            });
          } else {
            alert('Erro ao excluir: chave inv√°lida ou mensagem n√£o encontrada');
          }
        } catch (err) {
          alert('Erro ao excluir: ' + err.message);
        }
      }

      function renderMessages(messages, container, artefactId, loadMoreBtn, clearContainer = true) {
        if (clearContainer) container.innerHTML = '';
        
        if (!messages.length && clearContainer) {
          container.innerHTML = '<p class="note">Nenhum coment√°rio por enquanto‚Ä¶</p>';
          return;
        }
        
        // R√©cup√©rer les cl√©s stock√©es dans localStorage
        const userMessages = JSON.parse(localStorage.getItem('userMessages') || '{}');
        
        messages.forEach(m => {
          const div = document.createElement('div');
          div.className = 'note';
          div.innerHTML = `<strong>${m.author}</strong> ‚Äì <em>${new Date(m.created_at).toLocaleString('pt-BR')}</em><br>`;
          
          if (m.comment) {
            div.innerHTML += `<p style="margin:0 0 .5rem">${m.comment}</p>`;
          }
          
          if (m.audio_path) {
            const audioContainer = document.createElement('div');
            audioContainer.className = 'audio-lazy';
            audioContainer.innerHTML = `<button class="play-audio">‚ñ∂Ô∏è Ouvir √°udio</button>`;
            audioContainer.dataset.src = `${SUPABASE_URL}/storage/v1/object/public/recordings/${m.audio_path}`;
            
            audioContainer.querySelector('button').addEventListener('click', function() {
              const audio = document.createElement('audio');
              audio.controls = true;
              audio.src = audioContainer.dataset.src;
              this.replaceWith(audio);
              audio.play();
            });
            
            div.appendChild(audioContainer);
          }
          if (m.image_path) {
  const imgWrap = document.createElement('div');
  imgWrap.className = 'comment-media';
  const img = document.createElement('img');
  img.src = `${SUPABASE_URL}/storage/v1/object/public/comment-images/${m.image_path}`;
  img.alt = 'imagem do coment√°rio';
  imgWrap.appendChild(img);
  div.appendChild(imgWrap);
}

          // V√©rifier si ce message appartient √† l'utilisateur actuel
          if (userMessages[m.id]) {
            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = 'üóëÔ∏è Excluir';
            deleteBtn.className = 'delete-btn';
            deleteBtn.onclick = () => deleteMessage(m.id, userMessages[m.id], artefactId, container, loadMoreBtn);
            div.appendChild(deleteBtn);
          }
          
          container.appendChild(div);
        });
      }

      async function loadMessages(artefactId, upper, page = 0, limit = 10) {
        const cacheKey = `${artefactId}-${page}`;
        
        if (messageCache[cacheKey]) {
          renderMessages(messageCache[cacheKey], upper, artefactId, null, page === 0);
          return messageCache[cacheKey].length === limit;
        }
        
        const res = await fetch(`/.netlify/functions/get-messages?artefact=${encodeURIComponent(artefactId)}&page=${page}&limit=${limit}`);
        const data = await res.json();
        
        messageCache[cacheKey] = data; // Sauvegarder dans le cache
        renderMessages(data, upper, artefactId, null, page === 0);
        
        return data.length === limit;
      }

// Fonction pour rendre un artefact
function renderArtefact({ src, alt }) {
  const artefactId = src.split('/').pop(); // ex: image1.png

  /* --- structure DOM --- */
  const row = document.createElement('div'); 
  row.className = 'artefact';
  
  const img = document.createElement('img');
  img.alt = alt;
  img.src = src;
  img.loading = 'lazy'; 
  
  row.appendChild(img);

  const panel = document.createElement('div'); 
  panel.className = 'panel';

  const upper = document.createElement('div'); 
  upper.className = 'panel-upper'; 
  panel.appendChild(upper);

  const lower = document.createElement('div'); 
  lower.className = 'panel-lower';
  lower.innerHTML = `
    <input type="text" placeholder="Seu nome (opcional)" maxlength="50" />
    <textarea placeholder="Adicionar um coment√°rio‚Ä¶" maxlength="1000"></textarea>
    <div class="char-count">0 / 1000</div>
    <button data-publish>Publicar</button>
    <button style="margin-left:.5rem" data-audio>üó£Ô∏è Gravar</button>
    <button style="margin-left:.5rem" data-image>üñºÔ∏è Importar imagem</button>
    <input type="file" accept="image/png,image/jpeg,image/webp" data-image-input style="display:none" />
    <button style="margin-left:.5rem" class="loc-btn" data-artefact="${artefactId}">üìç Localizar</button>
    <div class="rec-info">
      <span class="rec-time"></span>
      <span class="file-size"></span>
    </div>
    <div class="preview" data-preview></div>
  `;
  panel.appendChild(lower); 
  row.appendChild(panel); 
  gallery.appendChild(row);

  // Bouton pour charger plus de commentaires
  const loadMoreBtn = document.createElement('button');
  loadMoreBtn.textContent = 'Carregar mais coment√°rios';
  loadMoreBtn.className = 'load-more-comments';
  loadMoreBtn.style.display = 'none';
  upper.after(loadMoreBtn);

    /* --- r√©f√©rences --- */
  const nameInput  = lower.querySelector('input');
  const textarea   = lower.querySelector('textarea');
  const publishBtn = lower.querySelector('[data-publish]');
  const audioBtn   = lower.querySelector('[data-audio]');
  const preview    = lower.querySelector('[data-preview]');
  const charCount  = lower.querySelector('.char-count');
  const imageBtn   = lower.querySelector('[data-image]');
  const imageInput = lower.querySelector('[data-image-input]');
  const recInfo    = lower.querySelector('.rec-info');
  const timerSpan  = lower.querySelector('.rec-time');
  const fileSize   = lower.querySelector('.file-size');

  // compteur caract√®res
  charCount.textContent = `${textarea.value.length} / 1000`;
  textarea.addEventListener('input', () => {
    charCount.textContent = `${textarea.value.length} / 1000`;
  });

  // ====== Variables AUDIO ======
  let startTime = null;
  let timerId = null;
  let recordingDuration = 0;
  let currentSize = 0;
  let tempBlob = null;
  let tempURL = null;
  let recorder = null;
  let chunks = [];
  let currentPage = 0;

  // ====== Variables IMAGE ======
  let tempImageBlob = null;
  let tempImageURL  = null;

  // ====== Aper√ßu IMAGE ======
function resetImagePreview() {
  if (tempImageURL) URL.revokeObjectURL(tempImageURL);
  tempImageURL = null;
  tempImageBlob = null;
  const box = preview.querySelector('.img-preview');
  if (box) box.remove();
}

function renderImagePreview() {
  resetImagePreview();
  if (!tempImageBlob) return;
  tempImageURL = URL.createObjectURL(tempImageBlob);

  const wrap = document.createElement('div');
  wrap.className = 'img-preview';
  wrap.style.display = 'flex';
  wrap.style.alignItems = 'center';
  wrap.style.gap = '.5rem';

  const img = document.createElement('img');
  img.src = tempImageURL;
  img.style.maxWidth = '160px';
  img.style.maxHeight = '120px';
  img.style.objectFit = 'contain';
  img.style.border = '1px solid var(--border)';
  img.style.borderRadius = '4px';

  const del = document.createElement('button');
  del.textContent = 'üóëÔ∏è';
  del.title = 'Excluir a imagem';
  del.onclick = resetImagePreview;

  wrap.append(img, del);
  preview.appendChild(wrap);
}

imageBtn.addEventListener('click', () => imageInput.click());

imageInput.addEventListener('change', () => {
  const f = imageInput.files && imageInput.files[0];
  console.log('[image] change fired. file =', f);         // debug
  if (!f) return;

  if (!/^image\/(png|jpe?g|webp)$/i.test(f.type)) {
    alert('Formato n√£o suportado. Use PNG, JPG ou WebP.');
    imageInput.value = '';
    return;
  }
  const MAX_IMAGE_BYTES = 800 * 1024;
  console.log('[image] size =', f.size);                   // debug
  if (f.size > MAX_IMAGE_BYTES) {
    alert('Imagem muito pesada (m√°x. 800KB).');
    imageInput.value = '';
    return;
  }
  tempImageBlob = f;
  renderImagePreview();
});


  // ====== Aper√ßu AUDIO ======
  recInfo.style.display = 'none';
 function resetPreview(){
  if (tempURL){ URL.revokeObjectURL(tempURL); tempURL=null; }
  tempBlob = null;
  // enl√®ve UNIQUEMENT l‚Äôaper√ßu audio
  const audioWrap = preview.querySelector('.audio-preview');
  if (audioWrap) audioWrap.remove();
}

function renderPreview(){
  if(!tempURL) return;
  // enl√®ve l‚Äôancien aper√ßu audio s‚Äôil existe
  const old = preview.querySelector('.audio-preview');
  if (old) old.remove();

  const wrap = document.createElement('div');
  wrap.className = 'audio-preview';
  wrap.style.display = 'flex';
  wrap.style.alignItems = 'center';
  wrap.style.gap = '.5rem';

  const audio = document.createElement('audio'); 
  audio.controls = true; 
  audio.src = tempURL;

  const durLabel = document.createElement('span');
  durLabel.textContent = ` ${formatTime(recordingDuration)}`;
  durLabel.style.fontSize = '.8rem';
  durLabel.style.color = '#aaa';

  const del = document.createElement('button'); 
  del.textContent = 'üóëÔ∏è'; 
  del.title = 'Excluir a grava√ß√£o';
  del.onclick = resetPreview; 

  wrap.append(audio, durLabel, del);
  preview.appendChild(wrap);
}

  // ====== STOP recording (utilis√©e partout) ======
  function stopRecording(reason = 'manual') {
    return new Promise(resolve => {
      if (!recorder || recorder.state !== 'recording') return resolve();

      if (startTime) {
        recordingDuration = Math.floor((Date.now() - startTime) / 1000);
      }

      const onStop = () => {
        recorder.removeEventListener('stop', onStop);
        if (timerId) { clearInterval(timerId); timerId = null; }
        recInfo.style.display = 'none';
        audioBtn.textContent = 'üó£Ô∏è Gravar';
        resolve();
      };
      recorder.addEventListener('stop', onStop, { once: true });

      try {
        recorder.stop();
        if (reason === 'size_limit') {
          setTimeout(() => {
            alert('Grava√ß√£o parou automaticamente antes de atingir o limite de 4 MB.');
          }, 300);
        }
      } catch (err) {
        console.error("Erreur lors de l'arr√™t du MediaRecorder :", err);
        onStop();
      }

      if (recorder.stream) {
        try { recorder.stream.getTracks().forEach(t => t.stop()); }
        catch (err) { console.error("Erreur lors de l'arr√™t des pistes audio :", err); }
      }
    });
  }

  // ====== Charger messages existants ======
  loadMessages(artefactId, upper).then(hasMore => {
    if (hasMore) loadMoreBtn.style.display = 'block';
  });
  loadMoreBtn.addEventListener('click', async () => {
    currentPage++;
    const hasMore = await loadMessages(artefactId, upper, currentPage);
    if (!hasMore) loadMoreBtn.style.display = 'none';
  });

  // ====== Enregistrement AUDIO ======
  audioBtn.addEventListener('click', async () => {
    if (!recorder || recorder.state === 'inactive') {
      try {
        resetPreview();
        chunks = [];
        currentSize = 0;
        recordingDuration = 0;

        recInfo.style.display = 'flex';
        timerSpan.textContent = '00:00';
        fileSize.textContent = '(0 B / 4 MB)';
        fileSize.className = '';

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        recorder.stream = stream;

        startTime = Date.now();
        timerId = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          timerSpan.textContent = formatTime(elapsed);
        }, 1000);

        recorder.addEventListener('dataavailable', e => {
          if (!e.data || !e.data.size) return;
          chunks.push(e.data);
          currentSize += e.data.size;
          fileSize.textContent = `(${formatFileSize(currentSize)} / 4 MB)`;
          if (currentSize >= CRITICAL_THRESHOLD) {
            fileSize.className = 'size-critical';
            stopRecording('size_limit');
          } else if (currentSize >= WARNING_THRESHOLD) {
            fileSize.className = 'size-warning';
          } else {
            fileSize.className = '';
          }
        });

        recorder.addEventListener('stop', () => {
          if (timerId) { clearInterval(timerId); timerId = null; }
          if (startTime) {
            recordingDuration = Math.floor((Date.now() - startTime) / 1000);
          }
          startTime = null;

          recorder.stream.getTracks().forEach(track => track.stop());
          try {
            tempBlob = new Blob(chunks, { type: 'audio/webm' });
            if (tempBlob.size > MAX_AUDIO_BYTES) {
              alert('O √°udio √© muito grande (m√°x. 4 MB). Grave novamente.');
              resetPreview();
              return;
            }
            tempURL = URL.createObjectURL(tempBlob);
            renderPreview();
          } catch (err) {
            console.error("Erreur lors de la cr√©ation du blob:", err);
            alert("Erro ao processar o √°udio gravado.");
            resetPreview();
          }
        });

        recorder.start(RECORDING_TIMESLICE);
        audioBtn.textContent = '‚èπÔ∏è Parar';
      } catch (err) {
        console.error("Erreur d'acc√®s ao micro:", err);
        alert('N√£o foi poss√≠vel acessar o microfone');
        recInfo.style.display = 'none';
      }
    } else if (recorder.state === 'recording') {
      stopRecording();
    }
  });

  // ====== Publish ======
  publishBtn.addEventListener('click', async () => {
    publishBtn.disabled = true;
    await stopRecording();

    const comment = textarea.value.trim();

    // Autoriser commentaire OU audio OU image
    if (!comment && !tempBlob && !tempImageBlob) {
      alert('Adicione um coment√°rio, grave um √°udio, ou importe uma imagem.');
      publishBtn.disabled = false;
      return;
    }

    if (tempBlob) {
      try {
        if (tempBlob.size > MAX_AUDIO_BYTES) {
          alert('O √°udio √© muito grande (m√°x. 4 MB).');
          publishBtn.disabled = false;
          return;
        }
        if (tempBlob.size === 0) {
          alert('O √°udio parece estar vazio. Grave novamente.');
          resetPreview();
          publishBtn.disabled = false;
          return;
        }
      } catch (error) {
        console.error("Erreur de v√©rification du blob:", error);
        alert("Erro ao verificar o √°udio.");
        resetPreview();
        publishBtn.disabled = false;
        return;
      }
    }

    try {
      let audioBase64 = null;
      if (tempBlob) {
        audioBase64 = await blobToBase64(tempBlob);
        if (!audioBase64) throw new Error("Falha na convers√£o do √°udio");
      }

let imageBase64 = null;
if (tempImageBlob) {
  const b64 = await blobToBase64(tempImageBlob);
  imageBase64 = `data:${tempImageBlob.type};base64,${b64}`;
}

const payload = {
  artefact_id: artefactId,
  author: nameInput.value.trim() || 'An√¥nimo',
  comment,
  audioBase64,   // ton code existant
  imageBase64    // ‚Üê AJOUT
};


      console.log("Envoi des donn√©es:",
        audioBase64 ? `(audio ~${Math.round(audioBase64.length * .75)} bytes)` : "sans audio",
        imageBase64 ? "+ image" : "");

      const res = await fetch('/.netlify/functions/add-message', {
        method: 'POST',
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Erreur serveur (${res.status}): ${errorText}`);
      }

      const { success, id, delete_token } = await res.json();
      if (success) {
        const userMessages = JSON.parse(localStorage.getItem('userMessages') || '{}');
        userMessages[id] = delete_token;
        localStorage.setItem('userMessages', JSON.stringify(userMessages));

        textarea.value = '';
        nameInput.value = '';
        resetPreview();
        resetImagePreview();
        if (imageInput) imageInput.value = '';

        // Invalide le cache & recharge
        Object.keys(messageCache).forEach(key => {
          if (key.startsWith(artefactId)) delete messageCache[key];
        });
        currentPage = 0;
        loadMessages(artefactId, upper).then(hasMore => {
          loadMoreBtn.style.display = hasMore ? 'block' : 'none';
        });
      } else {
        alert('Erro ao publicar');
      }
    } catch (error) {
      console.error('Erro ao publicar:', error);
      alert('Erro ao publicar: ' + error.message);
    } finally {
      publishBtn.disabled = false;
    }
  });
}
      
      // Fonction de chargement d'artefacts
      function loadArtefacts(count = 3) {
        if (isLoading || currentIndex >= images.length) return;
        
        isLoading = true;
        loadingIndicator.style.display = 'block';
        
        const nextImages = images.slice(currentIndex, currentIndex + count);
        currentIndex += count;
        
        setTimeout(() => {
          nextImages.forEach(renderArtefact);
          isLoading = false;
          loadingIndicator.style.display = 'none';
          
          // V√©rifier si nous avons besoin de charger plus d'images
          checkScrollPosition();
        }, 300); // Petit d√©lai pour une meilleure UX
      }

      // Fonction pour v√©rifier la position de d√©filement
      function checkScrollPosition() {
        if (isLoading || currentIndex >= images.length) return;
        
        const scrollPosition = window.innerHeight + window.scrollY;
        const bodyHeight = document.body.offsetHeight;
        
        // Charger plus d'artefacts si on approche du bas de la page
        if (scrollPosition > bodyHeight - 500) {
          loadArtefacts();
        }
      }

      // √âcouteur d'√©v√©nement pour le d√©filement
      window.addEventListener('scroll', checkScrollPosition);
      
      // Charger les premiers artefacts
      loadArtefacts();

    
/* D√©l√©gation de clic : fonctionne m√™me pour les .loc-btn cr√©√©s dynamiquement */
document.addEventListener('click', e => {
  const btn = e.target.closest('.loc-btn');
  if (btn) openMap(btn.dataset.artefact);
});
      
/* ----------------- variables globales ----------------- */
let map, drawnMarkers = [];          // tous les marqueurs d√©j√† enregistr√©s
let currentMarker = null;            // marqueur qu‚Äôon est en train de placer
let currentArtefactId = null;        // id de l‚Äôartefact s√©lectionn√©

/* ----------------- ouvrir la modale + charger les points ----------------- */
/* ----------------- ouvrir la modale + charger les points ----------------- */
async function openMap(artefactId){
  currentArtefactId = artefactId;
  const modal = document.getElementById('map-modal');
  modal.style.display = 'flex';

  /* bouton ‚úñÔ∏è */
  document.getElementById('closeMap').onclick = closeMap;

  /* ‚ûä carte Leaflet : init une seule fois */
  if (!map) {
    // Fonds de carte
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap', maxZoom: 19
    });
    const esriSat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Tiles ¬© Esri', maxZoom: 19 }
    );

    // ‚ö†Ô∏è Une seule initialisation !
    map = L.map('leaflet-container', {
      center: [-3, -63],
      zoom: 5,
      layers: [esriSat] // d√©marrer en satellite (ou mets osm si tu pr√©f√®res)
    });

    // Bascule Carte / Satellite
    L.control.layers({ 'Carte': osm, 'Satellite': esriSat }).addTo(map);

    // Clic ‚Üí place/d√©place le marqueur temporaire
    map.on('click', e => {
      if (currentMarker) map.removeLayer(currentMarker);
      currentMarker = L.marker(e.latlng, { draggable: true }).addTo(map);
    });
  } else {
    // Quand on rouvre la modale, recalcul des dimensions
    setTimeout(() => map.invalidateSize(), 100);
  }

  /* ‚ûã purge des anciennes couches (on garde les fonds de carte) */
  map.eachLayer(l => {
    if (!(l instanceof L.TileLayer)) map.removeLayer(l);
  });
  drawnMarkers = [];
  currentMarker = null;

  /* ‚ûå r√©cup√©rer les points existants */
  try {
    const res = await fetch('/.netlify/functions/get-locations?artefact=' + artefactId, { cache: 'no-store' });
    const points = res.ok ? await res.json() : [];

    points.forEach(p => {
      const m = L.marker([p.lat, p.lng]).addTo(map)
        .bindPopup(`${p.author || 'An√¥nimo'}<br>${new Date(p.created_at).toLocaleDateString()}`);
      drawnMarkers.push(m);
    });

    /* ‚ûç zoom sur l‚Äôensemble ou vue par d√©faut */
    if (points.length) {
      const group = L.featureGroup(drawnMarkers);
      map.fitBounds(group.getBounds().pad(0.25));
    } else {
      map.setView([-3, -63], 5);
    }
  } catch (e) {
    console.error(e);
  }
}

/* ----------------- fermer la modale ----------------- */
function closeMap(){
  document.getElementById('map-modal').style.display='none';
  if(currentMarker){ map.removeLayer(currentMarker); currentMarker=null; }
}

/* ----------------- enregistrement du point ----------------- */
document.getElementById('saveLoc').onclick = async () => {
  if (!currentMarker) {
    alert('Clique na carta para escolher o ponto.');
    return;
  }
  const { lat, lng } = currentMarker.getLatLng();
  const author = prompt('Seu nome (opcional)', '') || 'An√¥nimo';

  const res = await fetch('/.netlify/functions/set-location', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ artefact_id: currentArtefactId, lat, lng, author })
  });

  if (res.ok) {
    alert('Localiza√ß√£o salva!');
    currentMarker = null;
    closeMap();
  } else {
    alert('Erro: ' + (await res.text()));
  }
};

</script>

  </body>
</html>








